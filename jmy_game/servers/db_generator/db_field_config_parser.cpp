#include "db_field_config_parser.h"
#include <fstream>
#include <string>
#include <cassert>
#include <iostream>
#include <thread>

DBFieldConfigParser::DBFieldConfigParser()
{
}

DBFieldConfigParser::~DBFieldConfigParser()
{
	//clear();
}

bool DBFieldConfigParser::load(const char* config_path)
{
	std::ifstream in;

	in.open(config_path, std::ifstream::in);
	if (!in.is_open()) {
		std::cout << "failed to open " << config_path << std::endl;
		return false;
	}

	std::string line;
	std::string str;
	while (std::getline(in, line)) {
		str.append(line+"\n");
	}
	in.close();

	doc_.Parse<0>(str.c_str());
	if (doc_.HasParseError()) {
		std::cout << "parse " << config_path << " failed, err " << doc_.GetParseError() << std::endl;
		return false;
	}

	rapidjson::Value::ConstMemberIterator it = doc_.MemberBegin();
	for (; it!=doc_.MemberEnd(); ++it) {
		FieldInfo field_info;
		if (!parse_field((*it).name.GetString(), (*it).value, field_info)) {
			std::cout << "parse field " << it->name.GetString() << " failed" << std::endl;
			return false;
		}
		field_list_.push_back(field_info);
	}
	config_path_ = config_path;
	std::cout << "load " << config_path << " success" << std::endl;
	return true;
}

void DBFieldConfigParser::clear()
{
}

bool DBFieldConfigParser::generate()
{
	std::fstream out_file;
	std::string file_name;
	int index = config_path_.find_last_of("/");
	if (index < 0) {
		file_name = config_path_;
	} else {
		file_name = config_path_.substr(index+1);
	}
	index = file_name.find(".");
	if (index > 0) {
		file_name = file_name.substr(0, index);
	}
	std::cout << "file name is " << file_name.c_str() << std::endl;

	std::string db_proto_file = file_name + ".proto";
	out_file.open(db_proto_file, std::ios::out);
	out_file << "// Generated by the db_generator.  DO NOT EDIT!" << std::endl;
	out_file << "// source: " << file_name << std::endl;
	out_file << "syntax=\"proto3\";" << std::endl << std::endl;

	std::list<FieldInfo>::iterator it = field_list_.begin();
	for (; it!=field_list_.end(); ++it) {
		FieldInfo& field_info = *it;
		out_file << "message " << field_info.name << " {" << std::endl;
		std::vector<FieldMemberInfo>::iterator vit = field_info.members.begin();
		for (; vit!=field_info.members.end(); ++vit) {
			out_file << "  ";
			if (vit->repeated) {
				out_file << "repeated ";
			}
			out_file << vit->type << " " << vit->name << " = " << vit->index << ";" << std::endl;
		}
		out_file << "}" << std::endl << std::endl;
	}

	out_file.flush();
	std::this_thread::sleep_for(std::chrono::seconds(1));
	out_file.close();
	std::cout << "generated " << db_proto_file << std::endl;

	return true;
}

bool DBFieldConfigParser::parse_field(const std::string& field_name, const rapidjson::Value& v, FieldInfo& field_info)
{
	FieldMemberInfo mem_info;
	rapidjson::Value::ConstMemberIterator it = v.MemberBegin();
	for (; it!=v.MemberEnd(); ++it) {
		if (!parse_field_member(field_name, it->value, it->name.GetString(), mem_info)) {
			std::cout << "parse field " << field_name << " member " << it->name.GetString() << " failed" << std::endl;
			return false;
		}
		field_info.members.push_back(mem_info);
		field_info.name = field_name;
	}
	return true;
}

bool DBFieldConfigParser::parse_field_member(const std::string& field_name, const rapidjson::Value& v, const std::string& mem_name, FieldMemberInfo& mem_info)
{
	char* member = (char*)"index";
	if (!v.HasMember(member)) {
		std::cout << "parse field(" << field_name << ") member failed, field member " << mem_name << " not has member " << member << std::endl;
		return false;
	}
	if (!v[member].IsInt()) {
		std::cout << "parse field(" << field_name << ") member failed, field member " << mem_name << " type is not int" << std::endl;
		return false;
	}
	mem_info.index = v[member].GetInt();

	member = (char*)"type";
	if (!v.HasMember(member)) {
		std::cout << "parse field(" << field_name << ") member failed, field member " << mem_name << " not has member " << member << std::endl;
		return false;
	}
	if (!v[member].IsString()) {
		std::cout << "parse field(" << field_name << ") member failed, field member " << mem_name << " type is not string" << std::endl;
		return false;
	}
	mem_info.type = v[member].GetString();

	member = (char*)"repeated";
	if (v.HasMember(member)) {
		if (!v[member].IsBool()) {
			std::cout << "parse field(" << field_name << ") member failed, field_member " << mem_name << " type is not bool" << std::endl;
			return false;
		}
		mem_info.repeated = v[member].GetBool();
	} else {
		mem_info.repeated = false;
	}
	
	mem_info.name = mem_name;
	return true;
}
