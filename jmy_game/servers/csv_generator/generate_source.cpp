#include "generate_source.h"
#include <thread>
#include <chrono>
#include <iostream>

GenerateSource::GenerateSource() : key_index_(KEY_INDEX)
{
}

GenerateSource::~GenerateSource()
{
}

bool GenerateSource::init(const char* file_name)
{
	if (!parser_.load(file_name)) {
		std::cout << "load file " << file_name << " failed" << std::endl;
		return false;
	}

	std::string fn(file_name);
	int index = fn.find_last_of("/");
	if (index < 0) {
		std::cout << "table file name " << fn.c_str() << " not valid" << std::endl;
		return false;
	}
	fn = fn.substr(index+1);
	index = fn.find(".");
	if (index > 0) {
		fn = fn.substr(0, index);
	}
	std::cout << "file name is " << fn.c_str() << std::endl;

	file_name_ = fn; //std::string(file_name);
	std::string header_file_name = file_name_ + ".h";
	out_file_.open(header_file_name, std::ios::out);
	out_file_ << "// Generated by the csv_generator.  DO NOT EDIT!" << std::endl;
	out_file_ << "#pragma once" << std::endl;
	out_file_ << "#include \"../libjmy/jmy_object_set.hpp\"" << std::endl;
	out_file_ << "#include \"csv_parser.h\"" << std::endl;
	out_file_ << "#include <iostream>" << std::endl;

	CsvParser::lines_type& lines = parser_.getLines();
	const std::vector<std::string>& name_line = lines[NAME_LINE_INDEX];
	const std::vector<std::string>& type_line = lines[TYPE_LINE_INDEX];
	if (!writeStruct(name_line, type_line)) {
		std::cout << "write struct failed" << std::endl;
		return false;
	}
	if (!writeClassBody(lines)) {
		std::cout << "write class body failed" << std::endl;
		return false;
	}
	return true;
}

void GenerateSource::close()
{
	out_file_.flush();
	std::this_thread::sleep_for(std::chrono::seconds(1));
	out_file_.close();
	std::cout << "generated " << file_name_ << ".h" << std::endl;
	parser_.close();
}

bool GenerateSource::writeStruct(const std::vector<std::string>& fields_name, const std::vector<std::string>& fields_type)
{
	if (fields_name.size() == 0 || fields_name.size()!=fields_type.size())
		return false;

	out_file_ << "struct " << file_name_ << " {" << std::endl;
	size_t i = 0; size_t s = fields_name.size();
	for (; i<s; ++i) {
		if (fields_type[i] == "int") {
			out_file_ << "  int ";
		} else if (fields_type[i] == "int64") {
			out_file_ << "  int64_t ";
		} else if (fields_type[i] == "string") {
			out_file_ << "  std::string ";
		} else if (fields_type[i] == "bool") {
			out_file_ << "  bool ";
		} else {
			std::cout << "unsupported field type: " << fields_type[i] << std::endl;
			return false;
		}
		out_file_ << fields_name[i] << ";" << std::endl;
	}

	out_file_ << "};" << std::endl << std::endl;

	return true;
}

bool GenerateSource::writeClassBody(const CsvParser::lines_type& lines)
{
	std::string class_name = file_name_ + "_table";
	out_file_ << "class " << class_name << " {" << std::endl;
	out_file_ << "public:" << std::endl;
	out_file_ << "  " << class_name << "() {}" << std::endl;
	out_file_ << "  ~" << class_name << "{} {}" << std::endl;
	writeLoadFunc();
	writeParseDataFunc(lines);
	writeCloseFunc(lines);
	const std::vector<std::string>& type_line = lines[TYPE_LINE_INDEX];
	writeGetFunc(type_line);
	out_file_ << "private:" << std::endl;
	out_file_ << "  JmyObjectSet<" << type_line[key_index_] << ", " << file_name_ << "*> objs_;" << std::endl;
	out_file_ << "};" << std::endl;
	return true;
}

bool GenerateSource::writeLoadFunc()
{
	out_file_ << "  bool load(const char* file_path) {" << std::endl;
	out_file_ << "    CsvParser parser;" << std::endl;
	out_file_ << "    if (!parser.load(file_path)) {" << std::endl;
	out_file_ << "      std::cout << \"load file\" << file_path << \" failed\" << std::endl;" << std::endl;
	out_file_ << "      return false;" << std::endl;
	out_file_ << "    }" << std::endl;
	out_file_ << "    if (!parseData(parser.getLines())) {" << std::endl;
	out_file_ << "      std::cout << \"parse file \" << file_path << \" data failed\"" << std::endl;
	out_file_ << "      return false;" << std::endl;
	out_file_ << "    }" << std::endl;
	out_file_ << "    parser.close();" << std::endl;
	out_file_ << "    return true;" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}

bool GenerateSource::writeParseDataFunc(const CsvParser::lines_type& lines)
{
	out_file_ << "  bool parseData(const CsvParser::lines_type& lines) {" << std::endl;
	out_file_ << "    CsvParser::lines_type& lines = parser.getLines();" << std::endl;
	out_file_ << "    size_t s = line.size();" << std::endl;
	out_file_ << "    if (s < " << MIN_LINE_COUNT << ") {" << std::endl;
	out_file_ << "      std::cout << \"line count: \" << s << \" must be not less to \"" << MIN_LINE_COUNT << " << std::endl;" << std::endl;
	out_file_ << "      return false;" << std::endl;
	out_file_ << "    }" << std::endl << std::endl;

	const std::vector<std::string>& name_line = lines[NAME_LINE_INDEX];
	const std::vector<std::string>& type_line = lines[TYPE_LINE_INDEX];
	out_file_ << "    const std::vector<std::string>& name_line = lines[" << NAME_LINE_INDEX << "];" << std::endl;
	out_file_ << "    const std::vector<std::string>& type_line = lines[" << TYPE_LINE_INDEX << "];" << std::endl;
	out_file_ << "    " << file_name_ << " data;" << std::endl;

	out_file_ << "    for (size_t i=" << DATA_LINE_START_INDEX << "; i<" << lines.size() << "; ++i) {" << std::endl;
	out_file_ << "      const std::vector<std::string>& line = lines[i];" << std::endl;
	size_t field_index = 0;
	for (; field_index<lines.size(); ++field_index) {
		if (type_line[field_index] == "int") {
			out_file_ << "      data." << name_line[field_index] << " = std::atoi(line[j].c_str());" << std::endl;
		} else if (type_line[field_index] == "int64") {
			out_file_ << "      data." << name_line[field_index] << " = (int64_t)std::strtoull(line[j].c_str(), nullptr, 10);" << std::endl;
		} else if (type_line[field_index] == "string") {
			out_file_ << "      data." << name_line[field_index] << " = line[j];" << std::endl;
		} else if (type_line[field_index] == "bool") {
			out_file_ << "      data." << name_line[field_index] << " = (bool)std::atoi(line[j].c_str());" << std::endl;
		} else {
			std::cout << "unsupported field type: " << type_line[field_index] << std::endl;
			return false;
		}
	}
	out_file_ << "      " << file_name_ << "* d = new " << file_name_ << ";" << std::endl;
	out_file_ << "      *d = data;" << std::endl;
	out_file_ << "      objs_.insertKeyValue(data." << name_line[key_index_] << ", d);" << std::endl;
	out_file_ << "    }" << std::endl;
	out_file_ << "    return true;" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}

bool GenerateSource::writeCloseFunc(const CsvParser::lines_type& lines)
{
	out_file_ << "  void close() {" << std::endl;
	//const std::vector<std::string>& type_line = lines[NAME_LINE_INDEX];
	//std::string objs_type = "JmyObjectSet<" + type_line[key_index_] + ", " + file_name_+ "*>";
	out_file_ << "    objs_.clear(true);" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}

bool GenerateSource::writeGetFunc(const std::vector<std::string>& type_line)
{
	out_file_ << "  " << file_name_ << "* get(const " << type_line[key_index_] << "& key) {" << std::endl;
	out_file_ << "    return objs_.getByKey();" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}
