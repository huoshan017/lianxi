#include "generate_source.h"
#include <thread>
#include <chrono>
#include <iostream>

GenerateSource::GenerateSource() : key_index_(KEY_INDEX)
{
}

GenerateSource::~GenerateSource()
{
}

bool GenerateSource::init(const char* file_name)
{
	file_name_ = std::string(file_name);
	std::string header_file_name = file_name_ + ".h";
	out_file_.open(header_file_name, std::ios::out);
	out_file_ << "// Generated by the csv_generator.  DO NOT EDIT!" << std::endl;
	out_file_ << "#pragma once" << std::endl;
	out_file_ << "#include \"../libjmy/jmy_object_set.hpp\"" << std::endl;
	out_file_ << "#include \"csv_parser.h\"" << std::endl;
	out_file_ << "#include <iostream>" << std::endl;
	return true;
}

void GenerateSource::clear()
{
	out_file_.flush();
	std::this_thread::sleep_for(std::chrono::seconds(1));
	out_file_.close();
	std::cout << "generated " << file_name_ << ".h" << std::endl;
}

bool GenerateSource::writeStruct(std::vector<std::string>& fields_name, std::vector<std::string>& fields_type)
{
	if (fields_name.size() == 0 || fields_name.size()!=fields_type.size())
		return false;

	out_file_ << "struct " << file_name_ << " {" << std::endl;
	size_t i = 0; size_t s = fields_name.size();
	for (; i<s; ++i) {
		if (fields_type[i] == "int") {
			out_file_ << "  int ";
		} else if (fields_type[i] == "int64") {
			out_file_ << "  int64 ";
		} else if (fields_type[i] == "string") {
			out_file_ << "  std::string ";
		} else if (fields_type[i] == "bool") {
			out_file_ << "  bool ";
		} else {
			std::cout << "unsupported field type: " << fields_type[i] << std::endl;
			return false;
		}
		out_file_ << fields_name[i] << ";" << std::endl;
	}

	out_file_ << "};" << std::endl << std::endl;

	return true;
}

bool GenerateSource::writeClassBody()
{
	std::string class_name = file_name_ + "_table";
	out_file_ << "class " << class_name << " {" << std::endl;
	out_file_ << "public:" << std::endl;
	out_file_ << "  " << class_name << "() {}" << std::endl;
	out_file_ << "  ~" << class_name << "{} {}" << std::endl;
	writeLoadFunc();
	writeCloseFunc();
	out_file_ << "private:" << std::endl;
	out_file_ << "  JmyObjectSet<" << file_name_ << "> objs_;" << std::endl;
	out_file_ << "};" << std::endl;
	return true;
}

bool GenerateSource::writeLoadFunc()
{
	out_file_ << "  bool load(const char* file_name) {" << std::endl;
	out_file_ << "    CsvParser parser;" << std::endl;
	out_file_ << "    if (!parser.load(file_name)) {" << std::endl;
	out_file_ << "      std::cout << \"parse failed:\" << file_name << std::endl;" << std::endl;
	out_file_ << "      return false;" << std::endl;
	out_file_ << "    }" << std::endl << std::endl;

	out_file_ << "    CsvParser::lines_type& lines = parser.getLines();" << std::endl;
	out_file_ << "    size_t s = line.size();" << std::endl;
	out_file_ << "    if (s < MIN_LINE_COUNT) {" << std::endl;
	out_file_ << "      std::cout << \"line count: \" << s << \" must be great to MIN_LINE_COUNT(\" << MIN_LINE_COUNT << \")\" << std::endl;" << std::endl;
	out_file_ << "      return false;" << std::endl;
	out_file_ << "    }" << std::endl << std::endl;

	out_file_ << "    std::vector<std::string>& name_line = lines[NAME_LINE_INDEX];" << std::endl;
	out_file_ << "    std::vector<std::string>& type_line = lines[TYPE_LINE_INDEX];" << std::endl;
	out_file_ << "    " << file_name_ << " data;" << std::endl;
	out_file_ << "    size_t i = DATA_LINE_START_INDEX;" << std::endl;
	out_file_ << "    for (; i<s; ++i) {" << std::endl;
	out_file_ << "      std::vector<std::string>& line = lines[i];" << std::endl;
	out_file_ << "      size_t ls = line.size();" << std::endl;
	out_file_ << "      size_t j = 0;" << std::endl;
	out_file_ << "      for (; j<ls; ++j) {" << std::endl;
	out_file_ << "        if (type_line[j] == \"int\") {" << std::endl;
	out_file_ << "          data." << std::endl;
	out_file_ << "        } else if (type_line[j] == \"int64\") {" << std::endl;
	out_file_ << "        } else if (type_line[j] == \"string\") {" << std::endl;
	out_file_ << "        } else if (type_line[j] == \"bool\") {" << std::endl;
	out_file_ << "        }" << std::endl;
	out_file_ << "      }" << std::endl;
	out_file_ << "    }" << std::endl;
	out_file_ << "    objs_.insertKeyValue(" << std::endl;
	out_file_ << "    return true;" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}

bool GenerateSource::writeCloseFunc()
{
	out_file_ << "  void close() {" << std::endl;
	out_file_ << "  }" << std::endl;
	return true;
}
